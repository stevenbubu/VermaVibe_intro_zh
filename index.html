<!DOCTYPE html>
<html lang="zh-Hant">
  <head>
    <meta charset="UTF-8" />
    <!-- 使用 viewport-fit=cover + dvh 提升直立式可視高度精準度 -->
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, viewport-fit=cover"
    />
    <title>VermaVibe</title>
    <style>
      html,
      body {
        height: 100%;
        margin: 0;
        background: #000;
        overscroll-behavior: contain;
      }
      .stage {
        position: fixed;
        inset: 0;
        height: 100dvh; /* 動態視窗高度，避免手機直立時 100vh 工具列誤差 */
        display: flex; /* 保留置中視覺 */
        align-items: center;
        justify-content: center;
        user-select: none;
        background: #000;
        overflow: hidden;
        /* 未縮放允許垂直捲動；縮放時由 JS 改為 none */
        touch-action: pan-y;
      }
      .slide {
        max-width: 100vw;
        max-height: 100dvh;
        width: auto;
        height: auto;
        object-fit: contain;
        background: #000;
        will-change: transform;
        transform-origin: 0 0; /* 以元素左上為縮放原點 */
        touch-action: pan-y; /* JS 於縮放中改為 none */
        backface-visibility: hidden;
      }
      .hint {
        position: fixed;
        left: 50%;
        bottom: 16px;
        transform: translateX(-50%);
        color: #fff;
        font: 14px/1.6 system-ui, "Microsoft JhengHei", sans-serif;
        opacity: 0.8;
        text-align: center;
        transition: opacity 0.3s ease;
      }
      .hint.hidden {
        opacity: 0;
        pointer-events: none;
      }
      @media (prefers-reduced-motion: reduce) {
        .hint {
          transition: none !important;
        }
      }
    </style>
  </head>
  <body>
    <div class="stage" id="stage">
      <img id="viewer" class="slide" src="" alt="slide" draggable="false" />
    </div>

    <div class="hint" id="hint">電腦 ← → 鍵切換｜手機單擊可切換雙擊可放大</div>

    <script>
      // ===== 設定 =====
      const COUNT = 12;
      const FOLDER = "images/VermaVibe_20251217";
      const images = Array.from(
        { length: COUNT },
        (_, i) => `${FOLDER}/${String(i + 1)}.PNG`
      );

      const MIN_SCALE = 1,
        MAX_SCALE = 6;
      const DOUBLE_TAP_MS = 300,
        WHEEL_ZOOM_FACTOR = 1.1;

      const EPS = 0.2; // 邊界微緩衝，避免浮點造成黑邊
      const isTouchDevice = navigator.maxTouchPoints > 0;

      // 中心縮放（不跟游標）
      const DOUBLE_TAP_TARGET_SCALE = 2.5; // 觸控雙擊放大目標倍數
      const ZOOM_ANIM_MS = 220; // 雙擊縮放動畫時長

      // Tap 閾值（手機較寬鬆）
      const CLICK_THRESHOLD_PX = isTouchDevice ? 22 : 10;
      const CLICK_THRESHOLD_PY = isTouchDevice ? 22 : 10;
      const TAP_DURATION_MS = 250;

      // Swipe 閾值（距離 + 速度）
      const SWIPE_MIN_PX = isTouchDevice ? 48 : 36;
      const SWIPE_MIN_VELOCITY = 0.35; // px/ms

      // 慣性拖曳／反彈參數
      const INERTIA_MIN_SPEED = 0.02; // px/ms，低於此速即停止
      const INERTIA_FRICTION = 0.5; // 每幀速度衰減（~60fps）
      const BOUNCE_COEFF = 0.1; // 觸邊反彈反射係數
      const PAN_HISTORY_MS = 120; // 計算慣性速度的最後時間窗

      // ===== DOM =====
      const viewer = document.getElementById("viewer");
      const stage = document.getElementById("stage");
      const hint = document.getElementById("hint");

      // ===== 狀態 =====
      let idx = 0;
      let scale = 1;
      let tx = 0,
        ty = 0; // 位移（相對於置中偏移）
      let rafId = null,
        lastTap = 0;

      // 舞台尺寸（用 visualViewport 為主）
      let viewportW = 0,
        viewportH = 0;

      // 未縮放置中的尺寸/偏移（快取）
      let baseW = 0,
        baseH = 0;
      let baseLx = 0,
        baseLy = 0;

      // viewer 拖曳
      const pointers = new Map();
      let dragStart = null;

      // stage 拖曳（scale>1）
      let stageDragStart = null;

      // Tap / Swipe（僅 scale===1）
      let tapStartX = null,
        tapStartY = null,
        tapStartTime = 0;
      let lastMoveX = null,
        lastMoveY = null,
        lastMoveTime = 0;

      // 防跳動：互動期間延後重算（debounce + 髒旗）
      let recomputeTimer = null,
        viewportDirty = false;

      // 慣性拖曳
      let panAnimId = null;
      let panHistory = []; // {x, y, t}

      // 雙擊平滑縮放動畫互斥
      let zoomAnimId = null;

      // ===== 工具 =====
      const clamp = (v, min, max) => Math.min(max, Math.max(min, v));
      const nowMs = () => performance.now();

      function updateViewport() {
        const vv = window.visualViewport;
        if (vv && vv.width && vv.height) {
          viewportW = vv.width;
          viewportH = vv.height;
        } else {
          const r = stage.getBoundingClientRect();
          viewportW = r.width;
          viewportH = r.height;
        }
      }

      function computeContain(nw, nh) {
        const imgRatio = nw / nh,
          stageRatio = viewportW / viewportH;
        if (imgRatio > stageRatio)
          return { w: viewportW, h: viewportW / imgRatio };
        return { h: viewportH, w: viewportH * imgRatio };
      }

      function computeBaseTopLeft() {
        baseLx = (viewportW - baseW) / 2;
        baseLy = (viewportH - baseH) / 2;
      }

      // —— 注意：因為畫面以「置中」顯示，所有座標需帶入 baseLx/baseLy ——
      // 把 client 座標轉為圖片本地座標（含置中偏移 + 目前位移）
      function clientToImagePoint(clientX, clientY) {
        const ix = (clientX - baseLx - tx) / scale;
        const iy = (clientY - baseLy - ty) / scale;
        return { x: clamp(ix, 0, baseW), y: clamp(iy, 0, baseH) };
      }

      // ✅ 修正：放大後若內容仍 <= viewport，tx/ty 應固定在「縮放後置中」的位置
      function getPanBounds() {
        const contentW = baseW * scale;
        const contentH = baseH * scale;

        let minTx, maxTx, minTy, maxTy;

        if (contentW > viewportW) {
          // 內容寬比視窗寬：允許水平拖曳
          minTx = viewportW - baseLx - contentW - EPS;
          maxTx = -baseLx + EPS;
        } else {
          // 內容寬 <= 視窗寬：固定縮放後置中（不是 0）
          const txCenter = (-baseW * (scale - 1)) / 2;
          minTx = maxTx = txCenter;
        }

        if (contentH > viewportH) {
          // 內容高比視窗高：允許垂直拖曳
          minTy = viewportH - baseLy - contentH - EPS;
          maxTy = -baseLy + EPS;
        } else {
          // 內容高 <= 視窗高：固定縮放後置中（不是 0）
          const tyCenter = (-baseH * (scale - 1)) / 2;
          minTy = maxTy = tyCenter;
        }

        return { minTx, maxTx, minTy, maxTy };
      }

      function preventNativeIfZooming(e) {
        if (scale > 1) e.preventDefault?.();
      }

      // ===== 尺寸與佈局 =====
      function recomputeBaseSize() {
        updateViewport();

        // 取 naturalWidth/Height；若不可用則退回 visible 尺寸
        const nw = viewer.naturalWidth || viewer.width || viewer.offsetWidth;
        const nh = viewer.naturalHeight || viewer.height || viewer.offsetHeight;
        if (!nw || !nh || !viewportW || !viewportH) return;

        const s = computeContain(nw, nh);
        baseW = s.w;
        baseH = s.h;

        // ✅ 可選加強：把計算後尺寸直接套到元素，讓座標/邊界更準
        viewer.style.width = `${baseW}px`;
        viewer.style.height = `${baseH}px`;

        // 未縮放置中（視覺）
        computeBaseTopLeft();

        // 邊界以置中坐標為基準
        commit(true);
      }

      // ===== 視覺更新 =====
      function commit(needsClamp = true) {
        if (needsClamp) {
          const { minTx, maxTx, minTy, maxTy } = getPanBounds();
          tx = clamp(tx, minTx, maxTx);
          ty = clamp(ty, minTy, maxTy);
        }
        if (rafId) return;
        rafId = requestAnimationFrame(() => {
          viewer.style.transform = `translate3d(${tx}px, ${ty}px, 0) scale(${scale})`;
          setInteractionMode();
          rafId = null;
        });
      }

      function setInteractionMode() {
        if (scale === 1) {
          viewer.style.touchAction = "pan-y";
          stage.style.touchAction = "pan-y";
        } else {
          viewer.style.touchAction = "none";
          stage.style.touchAction = "none";
        }
      }

      function resetTransform() {
        stopPanInertia();
        stopZoomAnim();
        scale = 1;
        tx = 0;
        ty = 0;
        commit(true);
        scheduleRecompute(); // 還原後允許重算
      }

      // ===== 顯示圖片 =====
      function show(i) {
        stopPanInertia();
        stopZoomAnim();
        idx = (i + images.length) % images.length;
        const url = images[idx];

        hint.classList.toggle("hidden", idx !== 0);
        scale = 1;
        tx = 0;
        ty = 0;
        viewer.src = url;
        viewer.alt = `slide ${idx + 1}`;

        // 等 natural 尺寸可讀再重算，避免 0 尺寸誤判邊界
        viewer.onload = () => {
          const waitNatural = () => {
            const nw = viewer.naturalWidth;
            const nh = viewer.naturalHeight;
            if (!nw || !nh) {
              requestAnimationFrame(waitNatural);
              return;
            }
            recomputeBaseSize();
          };
          waitNatural();
        };
        viewer.onerror = () => {
          hint.textContent = `載入失敗：${url}（點擊可跳下一張）`;
          hint.classList.remove("hidden");
        };

        // 預載下一張（非阻塞）
        const pre = new Image();
        pre.decoding = "async";
        pre.src = images[(idx + 1) % images.length];
      }

      // 左右半邊換頁（僅 scale===1）
      function handlePositionalClick(clientX) {
        if (scale !== 1) return;
        const leftHalf = clientX < viewportW / 2;
        show(leftHalf ? idx - 1 : idx + 1);
      }

      // —— 縮放：以某 client 點為錨（含置中偏移） ——
      function zoomAtPoint(targetScale, clientX, clientY) {
        const s1 = clamp(targetScale, MIN_SCALE, MAX_SCALE);
        const p = clientToImagePoint(clientX, clientY);
        // 讓錨點（p）對齊 client 點
        tx = clientX - baseLx - p.x * s1;
        ty = clientY - baseLy - p.y * s1;
        scale = s1;
        commit(true);
      }

      // 中心縮放（不跟游標）
      function zoomAtCenter(targetScale) {
        zoomAtPoint(targetScale, viewportW / 2, viewportH / 2);
      }

      // 雙擊平滑縮放（觸控）：放大瞬間置中（動畫）
      function easeOutCubic(t) {
        return 1 - Math.pow(1 - t, 3);
      }
      function animateZoomAtCenter(targetScale, duration = ZOOM_ANIM_MS) {
        stopZoomAnim();

        // 重要：先更新 viewport，避免手機工具列造成中心點漂移
        updateViewport();

        const startScale = scale;
        const cX = viewportW / 2,
          cY = viewportH / 2;
        const p = clientToImagePoint(cX, cY);
        const sTarget = clamp(targetScale, MIN_SCALE, MAX_SCALE);
        const t0 = nowMs();

        const step = () => {
          const t = nowMs();
          const dt = Math.min(1, (t - t0) / duration);
          const s = startScale + (sTarget - startScale) * easeOutCubic(dt);

          tx = cX - baseLx - p.x * s;
          ty = cY - baseLy - p.y * s;
          scale = s;

          commit(true);

          if (dt < 1) {
            zoomAnimId = requestAnimationFrame(step);
          } else {
            stopZoomAnim();
            commit(true);
          }
        };
        step();
      }
      function stopZoomAnim() {
        if (zoomAnimId) cancelAnimationFrame(zoomAnimId);
        zoomAnimId = null;
      }

      // 慣性拖曳（放手後滑動並反彈）
      function startPanInertia(vx, vy) {
        stopPanInertia();
        let lastTs = nowMs();
        const step = () => {
          const ts = nowMs();
          const dt = Math.max(1, ts - lastTs);
          lastTs = ts;

          // 速度衰減
          const decay = Math.pow(INERTIA_FRICTION, dt / 16);
          vx *= decay;
          vy *= decay;

          // 位移更新
          tx += vx * dt;
          ty += vy * dt;

          // 觸邊反彈（反射速度、位置貼齊邊界）
          const { minTx, maxTx, minTy, maxTy } = getPanBounds();
          if (tx < minTx && vx < 0) {
            tx = minTx;
            vx *= -BOUNCE_COEFF;
          }
          if (tx > maxTx && vx > 0) {
            tx = maxTx;
            vx *= -BOUNCE_COEFF;
          }
          if (ty < minTy && vy < 0) {
            ty = minTy;
            vy *= -BOUNCE_COEFF;
          }
          if (ty > maxTy && vy > 0) {
            ty = maxTy;
            vy *= -BOUNCE_COEFF;
          }

          // 視覺更新（靠反彈維持邊界）
          commit(false);

          // 終止條件
          const small =
            Math.abs(vx) < INERTIA_MIN_SPEED &&
            Math.abs(vy) < INERTIA_MIN_SPEED;
          const inside =
            tx >= minTx && tx <= maxTx && ty >= minTy && ty <= maxTy;

          if (small && inside) {
            stopPanInertia();
            commit(true);
            return;
          }
          panAnimId = requestAnimationFrame(step);
        };
        panAnimId = requestAnimationFrame(step);
      }

      function stopPanInertia() {
        if (panAnimId) cancelAnimationFrame(panAnimId);
        panAnimId = null;
      }

      function recordPanHistory(px, py) {
        const t = nowMs();
        panHistory.push({ x: px, y: py, t });
        const cutoff = t - PAN_HISTORY_MS;
        while (panHistory.length && panHistory[0].t < cutoff)
          panHistory.shift();
      }

      function computePanVelocity() {
        if (panHistory.length < 2) return { vx: 0, vy: 0 };
        const a = panHistory[0],
          b = panHistory[panHistory.length - 1];
        const dt = Math.max(1, b.t - a.t);
        return { vx: (b.x - a.x) / dt, vy: (b.y - a.y) / dt };
      }

      // 防跳動：互動期間延後重算
      function isInteracting() {
        return (
          pointers.size > 0 ||
          !!stageDragStart ||
          scale > 1 ||
          !!panAnimId ||
          !!zoomAnimId
        );
      }

      function scheduleRecompute(delay = 320) {
        clearTimeout(recomputeTimer);
        if (isInteracting()) {
          viewportDirty = true;
          return;
        }
        viewportDirty = false;
        recomputeTimer = setTimeout(() => recomputeBaseSize(), delay);
      }

      function tryRecomputeAfterInteraction() {
        if (viewportDirty && !isInteracting()) scheduleRecompute(160);
      }

      // ===== Viewer：Pointer（只負責縮放/拖曳）=====
      viewer.addEventListener(
        "pointerdown",
        (e) => {
          stopPanInertia();
          pointers.set(e.pointerId, {
            x: e.clientX,
            y: e.clientY,
            type: e.pointerType,
          });

          if (scale > 1) {
            try {
              viewer.setPointerCapture(e.pointerId);
            } catch {}
          } else if (e.pointerType !== "touch") {
            try {
              viewer.setPointerCapture(e.pointerId);
            } catch {}
          }

          // 觸控雙擊：未縮放放大；已縮放還原（桌面 mouse/pen 禁用）
          const tNow = nowMs();
          if (e.pointerType === "touch" && tNow - lastTap < DOUBLE_TAP_MS) {
            animateZoomAtCenter(scale > 1 ? 1 : DOUBLE_TAP_TARGET_SCALE);
            lastTap = 0;
            return;
          }
          lastTap = e.pointerType === "touch" ? tNow : 0;

          if (pointers.size === 1) {
            if (scale > 1) {
              const p = pointers.get(e.pointerId);
              dragStart = { x: p.x, y: p.y, tx0: tx, ty0: ty };
              panHistory.length = 0;
              recordPanHistory(p.x, p.y);
            }
          } else if (pointers.size === 2) {
            // 禁用雙指捏合縮放
            stopPanInertia();
          }
        },
        { passive: false }
      );

      viewer.addEventListener(
        "pointermove",
        (e) => {
          if (!pointers.has(e.pointerId)) return;
          preventNativeIfZooming(e);

          pointers.set(e.pointerId, {
            x: e.clientX,
            y: e.clientY,
            type: e.pointerType,
          });

          // 禁用雙指捏合縮放；保留縮放後單指拖曳
          if (pointers.size === 1 && dragStart && scale > 1) {
            const cur = pointers.get(e.pointerId);
            tx = dragStart.tx0 + (cur.x - dragStart.x);
            ty = dragStart.ty0 + (cur.y - dragStart.y);
            recordPanHistory(cur.x, cur.y);
            commit(true);
          }
        },
        { passive: false }
      );

      viewer.addEventListener("pointerup", (e) => {
        pointers.delete(e.pointerId);
        try {
          viewer.releasePointerCapture(e.pointerId);
        } catch {}
        if (pointers.size === 0) {
          // 慣性：單指拖曳結束後才進行
          if (dragStart && scale > 1) {
            const { vx, vy } = computePanVelocity();
            if (
              Math.abs(vx) >= INERTIA_MIN_SPEED ||
              Math.abs(vy) >= INERTIA_MIN_SPEED
            ) {
              startPanInertia(vx, vy);
            }
          }
          dragStart = null;
          setInteractionMode();
          scheduleRecompute();
          tryRecomputeAfterInteraction();
        }
      });

      viewer.addEventListener("pointercancel", () => {
        pointers.clear();
        dragStart = null;
        setInteractionMode();
        scheduleRecompute();
        tryRecomputeAfterInteraction();
      });

      // ===== Stage：Tap + Swipe（scale===1），Drag（scale>1）=====
      stage.addEventListener(
        "pointerdown",
        (e) => {
          stopPanInertia();
          pointers.set(e.pointerId, {
            x: e.clientX,
            y: e.clientY,
            type: e.pointerType,
          });

          if (scale > 1) {
            stageDragStart = { x: e.clientX, y: e.clientY, tx0: tx, ty0: ty };
            panHistory.length = 0;
            recordPanHistory(e.clientX, e.clientY);
            try {
              stage.setPointerCapture(e.pointerId);
            } catch {}
            return;
          }
          if (e.buttons && e.buttons !== 1) return; // 僅主鍵/觸控
          tapStartX = e.clientX;
          tapStartY = e.clientY;
          tapStartTime = nowMs();
          lastMoveX = tapStartX;
          lastMoveY = tapStartY;
          lastMoveTime = tapStartTime;
        },
        { passive: false }
      );

      stage.addEventListener(
        "pointermove",
        (e) => {
          preventNativeIfZooming(e);

          if (scale > 1 && stageDragStart) {
            tx = stageDragStart.tx0 + (e.clientX - stageDragStart.x);
            ty = stageDragStart.ty0 + (e.clientY - stageDragStart.y);
            recordPanHistory(e.clientX, e.clientY);
            commit(true);
            return;
          }
          lastMoveX = e.clientX;
          lastMoveY = e.clientY;
          lastMoveTime = nowMs();
        },
        { passive: false }
      );

      stage.addEventListener("pointerup", (e) => {
        pointers.delete(e.pointerId);
        if (scale > 1) {
          const { vx, vy } = computePanVelocity();
          if (
            Math.abs(vx) >= INERTIA_MIN_SPEED ||
            Math.abs(vy) >= INERTIA_MIN_SPEED
          ) {
            startPanInertia(vx, vy);
          }
          stageDragStart = null;
          try {
            stage.releasePointerCapture(e.pointerId);
          } catch {}
          scheduleRecompute();
          tryRecomputeAfterInteraction();
          return;
        }

        // scale===1：tap 或 swipe 換頁
        const endX = e.clientX,
          endY = e.clientY;
        const endTime = nowMs();
        const dx = endX - (tapStartX ?? endX);
        const dy = endY - (tapStartY ?? endY);
        const dt = endTime - (tapStartTime || endTime);

        const mvDt = Math.max(1, endTime - (lastMoveTime || endTime));
        const mvDx = endX - (lastMoveX ?? endX);
        const velocityX = Math.abs(mvDx) / mvDt; // px/ms

        const absDx = Math.abs(dx),
          absDy = Math.abs(dy);
        const isSwipe =
          absDx > SWIPE_MIN_PX &&
          absDx > absDy * 1.5 &&
          velocityX >= SWIPE_MIN_VELOCITY;

        if (isSwipe) {
          show(dx < 0 ? idx + 1 : idx - 1);
        } else {
          if (
            absDx <= CLICK_THRESHOLD_PX &&
            absDy <= CLICK_THRESHOLD_PY &&
            dt <= TAP_DURATION_MS
          ) {
            handlePositionalClick(endX);
          }
        }

        tapStartX = tapStartY = null;
        tapStartTime = 0;
        lastMoveX = lastMoveY = null;
        lastMoveTime = 0;
      });

      stage.addEventListener("pointercancel", () => {
        pointers.clear();
        stageDragStart = null;
        tapStartX = tapStartY = null;
        tapStartTime = 0;
        lastMoveX = lastMoveY = null;
        lastMoveTime = 0;
        scheduleRecompute();
        tryRecomputeAfterInteraction();
      });

      stage.addEventListener("contextmenu", (e) => e.preventDefault());

      // ===== 滾輪（縮放；永久禁用平移）=====
      const onWheel = (e) => {
        // Ctrl+滾輪：縮放（中心錨點）
        if (e.ctrlKey) {
          e.preventDefault();
          const factor =
            Math.sign(e.deltaY) > 0 ? 1 / WHEEL_ZOOM_FACTOR : WHEEL_ZOOM_FACTOR;
          const target = clamp(scale * factor, MIN_SCALE, MAX_SCALE);
          zoomAtCenter(target);
          return;
        }
        // 永久禁用滾輪平移：忽略
      };
      stage.addEventListener("wheel", onWheel, { passive: false });

      // ===== 鍵盤 =====
      document.addEventListener("keydown", (e) => {
        const key = e.key;
        if (key === "ArrowLeft") {
          e.preventDefault();
          show(idx - 1);
        } else if (key === "ArrowRight") {
          e.preventDefault();
          show(idx + 1);
        } else if (key === "Home") {
          e.preventDefault();
          show(0);
        } else if (key === "End") {
          e.preventDefault();
          show(images.length - 1);
        } else if (key === " ") {
          e.preventDefault();
          show(idx + 1);
        } else if (key.toLowerCase() === "r") {
          e.preventDefault();
          resetTransform();
        } else if (key === "+" || key === "=") {
          e.preventDefault();
          zoomAtCenter(clamp(scale * WHEEL_ZOOM_FACTOR, MIN_SCALE, MAX_SCALE));
        } else if (key === "-" || key === "_") {
          e.preventDefault();
          zoomAtCenter(clamp(scale / WHEEL_ZOOM_FACTOR, MIN_SCALE, MAX_SCALE));
        }
      });

      // ===== 舞台尺寸變更（排程）=====
      function onViewportChange() {
        viewportDirty = true;
        scheduleRecompute(); // 互動中不重算，結束後再補
      }
      window.addEventListener("resize", onViewportChange);
      if (window.visualViewport) {
        window.visualViewport.addEventListener("resize", onViewportChange);
      }
      window.addEventListener("orientationchange", onViewportChange);

      // ===== 初始化 =====
      show(0);
    </script>
  </body>
</html>
